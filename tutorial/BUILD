load("@halide//:halide.bzl", "halide_language_copts", "halide_language_linkopts", "halide_runtime_linkopts", "halide_library")

cc_library(
    name = "clock",
    hdrs = ["clock.h"],
)

# Many of the tutorials have trivial rules
[cc_binary(
    name = t,
    srcs = ["%s.cpp" % t],
    copts = halide_language_copts(),
    linkopts = halide_language_linkopts(),
    deps = ["@halide//:language"],
) for t in [
    "lesson_01_basics",
    "lesson_03_debugging_1",
    "lesson_04_debugging_2",
    "lesson_05_scheduling_1",
    "lesson_06_realizing_over_shifted_domains",
    "lesson_08_scheduling_2",
    "lesson_11_cross_compilation",
    "lesson_13_tuples",
    "lesson_14_types",
]]

# Several tutorials also depend on //tools:halide_image_io and require setting TUTORIAL_IMAGES_DIR
[cc_binary(
    name = t,
    srcs = [
        "%s.cpp" % t,
    ],
    copts = halide_language_copts() + [
        "-DTUTORIAL_IMAGES_DIR=\\\"%s/images/\\\"" % PACKAGE_NAME,
    ],
    data = glob(["images/*.png"]),
    linkopts = halide_language_linkopts(),
    deps = [
        "@halide//:language",
        "@halide//tools:halide_image_io",
        ":clock",
    ],
) for t in [
    "lesson_02_input_image",
    "lesson_07_multi_stage_pipelines",
    "lesson_09_update_definitions",
    "lesson_12_using_the_gpu",
]]

# For Lesson 10, we must build a binary, execute it, and depend on the output from that execution.
cc_binary(
    name = "lesson_10_aot_compilation_generate_gen",
    srcs = ["lesson_10_aot_compilation_generate.cpp"],
    copts = halide_language_copts(),
    linkopts = halide_language_linkopts(),
    deps = ["@halide//:language"],
)

genrule(
    name = "lesson_10_aot_compilation_generate_exec",
    outs = [
        "lesson_10_halide.a",
        "lesson_10_halide.h",
    ],
    cmd = "$(location :lesson_10_aot_compilation_generate_gen) $(@D)/",
    tools = [":lesson_10_aot_compilation_generate_gen"],
)

cc_library(
    name = "lesson_10_aot_compilation_generate_lib",
    srcs = [":lesson_10_aot_compilation_generate_exec"],
    hdrs = ["lesson_10_halide.h"],
    includes = ["."],
    linkstatic = 1,
)

cc_binary(
    name = "lesson_10_aot_compilation_run",
    srcs = [
        "lesson_10_aot_compilation_run.cpp",
    ],
    linkopts = halide_runtime_linkopts(),
    deps = [
        "@halide//:language",
        ":lesson_10_aot_compilation_generate_lib",
    ],
)

# For Lesson 15, we manurally build and use a Generator.
# (You normally would use the halide_library() rule to do this for you.)
cc_binary(
    name = "lesson_15_generators",
    srcs = ["lesson_15_generators.cpp"],
    copts = halide_language_copts(),
    linkopts = halide_language_linkopts(),
    deps = [
        "@halide//:language",
        "@halide//tools:gengen",
    ],
)

sh_binary(
    name = "lesson_15_generators_usage",
    srcs = ["lesson_15_generators_usage.sh"],
    args = ["$(location :lesson_15_generators)"],
    data = [":lesson_15_generators"],
)

# For Lesson 16, we use halide_library() to simplify Generator usage
[halide_library(
    name = "brighten_%s" % layout,
    srcs = ["lesson_16_rgb_generate.cpp"],
    generator_args = "layout=%s" % layout,
    includes = ["."],
) for layout in [
    "planar",
    "interleaved",
    "either",
    "specialized",
]]

cc_binary(
    name = "lesson_16_rgb_run",
    srcs = [
        "lesson_16_rgb_run.cpp",
    ],
    linkopts = halide_runtime_linkopts(),
    deps = [
        ":brighten_either",
        ":brighten_interleaved",
        ":brighten_planar",
        ":brighten_specialized",
        ":clock",
    ],
)
